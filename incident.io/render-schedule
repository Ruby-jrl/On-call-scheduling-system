#!/usr/bin/env python3
import argparse
import json
from helper import parse_time, fmt_time, load_json
from schedule_generation import generate_base_schedule, apply_overrides, merge_adjacent

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("--schedule", required=True)
    parser.add_argument("--overrides", required=True)
    parser.add_argument("--from", dest="from_", required=True)
    parser.add_argument("--until", required=True)
    args = parser.parse_args()

    # Load arguments and handle errors
    try:
        schedule = load_json(args.schedule)
    except Exception as e:
        raise ValueError(f"Error loading schedule from '{args.schedule}': {e}")

    try:
        overrides = load_json(args.overrides)
    except Exception as e:
        print(f"No overrides loaded or error")
        overrides = []
    
    try:
        from_dt = parse_time(args.from_)
    except Exception as e:
        raise ValueError(f"Error parsing 'from' date: {e}")

    try:
        until_dt = parse_time(args.until)
    except Exception as e:
        raise ValueError(f"Error parsing 'until' date: {e}")

    # More sensible error checks
    if from_dt >= until_dt:
        raise ValueError("from_dt must be before until_dt")

    base = generate_base_schedule(schedule, from_dt, until_dt)
    final = apply_overrides(base, overrides)
    final.sort(key=lambda e: e["start_at"])
    final = merge_adjacent(final)

    # Output ISO8601 strings
    for e in final:
        e["start_at"] = fmt_time(e["start_at"])
        e["end_at"] = fmt_time(e["end_at"])

    print(json.dumps(final, indent=2))

if __name__ == "__main__":
    main()